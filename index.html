<h6>Favourate place to buy food is :Hyderabad</h6>

<p> The famous Places for Shopping.The visiting places in Hyderabad include<b> Hussain sagar, Nagarjunasagar dam, Golconda.</b>
    This place is ruled by Navab Sultans.The Famous Construction<b> CHARMINAR was built by KULI KUTHUB SHAH</b> has become known globally as a symbol of Hyderabad and is listed among the most recognised structures in India.
    
</p>
<hr>

<h1>Route Map to Airport</h1>

The Closest Airport to Hyderabad paradise is Rajiv Gandhi International Airport.</br>
Steps to reach Airport:
    <ol type = "1">
        <li>The distance between Hyderabad Airport to Paradise Biryani Hyderabad is 10Kms by road.
           So travel by bus or cab.
        </li>
        <li> After boarding, travel 6kms towards east</li>
        <li>After reaching signal, go left to reach paradise hotel</li>
        <li>After reaching hotel, board steps and Go inside to eat </li>
    </ol>  
    Food Items
<ul>
    <li>Main Courses</li>
       <ul>
           <li>Biryani</li>
           <li>Plain Meal</li>
           <li>Fried Rices</li>
       </ul>  
    <li>Starters</li> 
       <ul>
           <li>Chicken Lolipops</li>
           <li>Drumsticks</li>
           <li>Spicy Guacamole</li>
           <li>Methi Muthia</li>
           <li>Air Fryer Falafel</li>
           <li>Paneer Tikka</li>
           <li>Sweet Potato Tikki</li>
       </ul>  
</ul> 

<a href ="aboutme.html">sAboutme</a>
<hr>

<b><h1 style="color:blue;">Tables creation.</h1></b>
<table>
    <tr>
        <th>Name</th>
        <th>Location</th>
        <th>Amount</th>
    </tr>
    <tr>
        <td>Football</td>
        <td>UAE</td>
        <td>$20</td>
        
    </tr>
    <tr>
        <td>Volleyball</td>
        <td>Hyderabad</td>
        <td>$210</td>
    </tr>
    <tr>
        <td>Throwball</td>
        <td>Khammam</td>
        <td>$100</td>
    </tr>
    <tr>
        <td>Cricket</td>
        <td>USA</td>
        <td>$25</td>
    </tr>
</table>
<hr>
<h1>Dynamic Programming Linear Algebra Numerical Methods </h1>
<blockquote cite="https://en.wikipedia.org/wiki/Dynamic_programming">
    Some dynamic programming problems have a recurrence of this form: \(\) Where  is a cost function and  when .
    Say  and , and evaluating  takes  time. Then the straightforward evaluation of the above recurrence is . There are  states, and  transitions for each state.
    Let  be the value of  that minimizes the above expression. If  for all , then we can apply divide-and-conquer DP. This is known as the monotonicity condition. The optimal "splitting point" for a fixed  increases as  increases.
    This lets us solve for all states more efficiently. Say we compute  for some fixed  and . Then for any  we know that . This means when computing , we don't have to consider as many splitting points!
</blockquote>
<pre>
    int m, n;
    vector<long long> dp_before(n), dp_cur(n);
    
    long long C(int i, int j);
    
    // compute dp_cur[l], ... dp_cur[r] (inclusive)
    void compute(int l, int r, int optl, int optr) {
        if (l > r)
            return;
    
        int mid = (l + r) >> 1;
        pair<long long, int> best = {LLONG_MAX, -1};
    
        for (int k = optl; k <= min(mid, optr); k++) {
            best = min(best, {(k ? dp_before[k - 1] : 0) + C(k, mid), k});
        }
    
        dp_cur[mid] = best.first;
        int opt = best.second;
    
        compute(l, mid - 1, optl, opt);
        compute(mid + 1, r, opt, optr);
    }
    
    int solve() {
        for (int i = 0; i < n; i++)
            dp_before[i] = C(0, i);
    
        for (int i = 1; i < m; i++) {
            compute(0, n - 1, 0, n - 1);
            dp_before = dp_cur;
        }
    
        return dp_before[n - 1];
    }
    
</pre>